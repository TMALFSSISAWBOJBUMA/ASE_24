#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"

#define DHT_PIN 4

static const char *TAG = "DHT11";

void delay_us(uint32_t us) {
    const uint32_t delay_period = us * (APB_CLK_FREQ / 1000000);
    uint32_t start_time = esp_timer_get_time();
    while ((esp_timer_get_time() - start_time) < delay_period);
}

void dht_start_signal() {
    gpio_set_direction(DHT_PIN, GPIO_MODE_OUTPUT);
    gpio_set_level(DHT_PIN, 0);
    delay_us(18000);
    gpio_set_level(DHT_PIN, 1);
    delay_us(30);
    gpio_set_direction(DHT_PIN, GPIO_MODE_INPUT);
}

int dht_read_data(uint8_t *data) {
    uint8_t buffer[5] = {0};
    uint8_t bit_count = 0;
    uint8_t byte_count = 0;

    dht_start_signal();

    // Odczytaj 40 bitów danych
    for (int i = 0; i < 40; i++) {
        // Odczekaj na zbocze opadające
        while (gpio_get_level(DHT_PIN) == 1);
        // Zaczekaj na zbocze rosnące, odczekaj 28 us
        uint32_t start_time = esp_timer_get_time();
        while (gpio_get_level(DHT_PIN) == 0);
        uint32_t pulse_width = esp_timer_get_time() - start_time;
        if (pulse_width > 70) {  // Jeśli szerokość impulsu jest większa niż 70 us, jest to bit 1
            buffer[byte_count] |= (1 << (7 - bit_count));
        }
        bit_count++;
        if (bit_count == 8) {
            bit_count = 0;
            byte_count++;
        }
    }

    // Weryfikacja sumy kontrolnej
    if (buffer[4] == ((buffer[0] + buffer[1] + buffer[2] + buffer[3]) & 0xFF)) {
        for (int i = 0; i < 4; i++) {
            data[i] = buffer[i];
        }
        return 0;  // Sukces
    } else {
        return -1; // Błąd sumy kontrolnej
    }
}

void dht_task(void *pvParameter) {
    uint8_t data[5] = {0};
    float humidity, temperature;

    while(1) {
        if (dht_read_data(data) == 0) {
            humidity = data[0] + data[1] / 10.0;
            temperature = data[2] + data[3] / 10.0;
            ESP_LOGI(TAG, "Temperature: %.1f°C, Humidity: %.1f%%", temperature, humidity);
        } else {
            ESP_LOGE(TAG, "Failed to read data from DHT11");
        }
        vTaskDelay(pdMS_TO_TICKS(2000)); // Odczyt co 2 sekundy
    }
}

void app_main() {
    ESP_ERROR_CHECK(gpio_install_isr_service(0)); // Instalacja usługi obsługi przerwań GPIO
    gpio_set_pull_mode(DHT_PIN, GPIO_PULLUP_ONLY); // Włączenie wbudowanego rezystora podciągającego
    xTaskCreate(&dht_task, "dht_task", configMINIMAL_STACK_SIZE * 3, NULL, 5, NULL);
}

